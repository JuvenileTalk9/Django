# データベース連携

4章までで、DjangoのMTVモデルのうち、T（Template）とV（View）の実装方法を確認しました。5章では、データベースを操作するM（Model）の実装方法を確認します。

DjangoにはデフォルトでSQLite3が搭載されており、初期設定でSQLite3にデータを書き込みます。ここではSQLite3を操作するモデルの実装方法を確認したあと、データベースシステムをPostgreSQLに変更する方法を確認します。

## 設定の確認

データベースに関する設定項目は、```settings.py```の```DATABASES```で管理されています。

```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

デフォルトで```ENGINE```にSQLite3が指定されており、プロジェクトディレクトリ直下の```db.sqlite3```ファイルが実態であることが```NAME```に設定されています。

## モデルを作成する

次に、モデルを実装します。モデルは```blog/models.py```に実装します。Djangoのモデルは、```django.db.models.Model```クラスを継承したサブクラスとして定義します。代表的なここではブログの投稿情報を管理する```BlogPost```クラスを作成します。管理する情報は以下とします。

|フィールド名|説明|型|オプション|
|:--|:--|:--|:--|
|id|記事ナンバー|整数（自動連番）|主キー|
|title|タイトル|文字列|256文字以下|
|content|本文|長い文字列|-|
|posted_at|投稿日時|日時|-|
|category|カテゴリ|文字列|読書・ゲーム・音楽から1つ選択|

Djangoは型ごとにフィールドクラスを定義しています。代表的なフィールドを示します。

|フィールドクラス名|概要|
|:--|:--|
|IntegerField|-2147483648～+2147483647の値の整数フィールド|
|AutoField|自動的に連番が振られるIntegerField|
|BigAutoField|より大きい整数値を格納できるAutoField|
|FloatField|浮動小数点のフィールド|
|BooleanField|真偽値のフィールド|
|CharField|文字列のフィールド。最大文字列長```max_length```を指定する必要がある|
|TextField|大きな文字列を格納するフィールド。```max_length```を指定する必要がない|
|DateField|日付のフィールド|
|TimeField|時刻のフィールド|
|DateTimeField|日時のフィールド|

これらを使って実装した```BlogPost```クラスは以下になります。

```py
class BlogPost(models.Model):

    CATEGORY = (('Book', '読書'), ('Game', 'ゲーム'), ('Music', '音楽'))

    id = models.AutoField(
        primary_key=True
    )

    title = models.CharField(
        varbose_name='タイトル',
        max_length=256
    )

    content = models.TextField(
        varbose_name='本文'
    )

    postged_at = models.DateTimeField(
        varbose_name='投稿日時',
        auto_now_add=True
    )

    category = models.CharField(
        varbose_name='カテゴリ',
        max_length=50,
        choices=CATEGORY
    )

    def __str__(self):
        return self.title
```

末尾に実装した```__str__```関数については後述します。

## マイグレーション

Djangoには、データベースのテーブルを作成する仕組みとして「マイグレーション」が実装されています。具体的には、先ほど作成したモデル定義を用いてテーブルを作成するPythonコードを自動で生成します。開発者は、生成されたコードを実行するだけでデータベースにテーブルを作成することができます。マイグレーションは、```manage.py```を用いて以下のように実行します。

```sh
$ python mangae.py makemigrations [アプリ名]
```

今回はアプリ名は```blog```になります。

```sh
$ python manage.py makemigrations blog
Migrations for 'blog':
  blog/migrations/0001_initial.py
    - Create model BlogPost
```

生成された```blog/migrations/0001_initial.py```は以下にようになっています。

```py
# Generated by Django 3.2 on 2021-07-08 15:34

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='BlogPost',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=256, verbose_name='タイトル')),
                ('content', models.TextField(verbose_name='本文')),
                ('postged_at', models.DateTimeField(auto_now_add=True, verbose_name='投稿日時')),
                ('category', models.CharField(choices=[('Book', '読書'), ('Game', 'ゲーム'), ('Music', '音楽')], max_length=50, verbose_name='カテゴリ')),
            ],
        ),
    ]
```

次に、生成されたマイグレーションファイルを実行し、テーブルの作成を行います。マイグレーションファイルの実行は、```migrate```オプションを使用します。

```sh
$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying blog.0001_initial... OK
  Applying sessions.0001_initial... OK
```

これでデータベースが作成され、Webアプリから操作できるようになりました。

## 管理ページからデータベースを操作する

```startapp```コマンドでblogを作成したときに、```admin.py```というモジュールも同時に生成されました。Djangoには登録したモデルに対してデータの追加・削除・編集が実験できる管理サイトが実装されており、```admin.py```はモデルの登録を行うモジュールになっています。```blog/admin.py```を以下のように編集します。

```py
from django.contrib import admin
from .models import BlogPost

admin.site.register(BlogPost)
```

Djangoの管理サイトはテーブルの情報が閲覧できてしまう重要なサイトのため、事前に登録された管理者ユーザのみログインできるような仕組みとなっています。管理者ユーザは```createsuperuser```コマンドで登録します。以下のようにユーザ名、メールアドレス、パスワードを登録します（外部に公開されるものではないので適当でOKです）。

```sh
$ python manage.py createsuperuser
ユーザー名 (leave blank to use 'centos'): centos
メールアドレス: admin@example.com
Password: 
Password (again): 
Superuser created successfully.
```

アカウントを作ったら開発用サーバを起動し、[http://127.0.0.1:8000/admin](http://127.0.0.1:8000/admin)に接続し、登録したユーザ名とパスワードでログインします。

![kanri_top.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/kanri_top.png)

Blog Postsの欄にある「追加ボタン」を押すと、テーブルに挿入するレコードの内容を入力できます。

![insert.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/insert.png)

「保存」ボタンでテーブルにレコードが挿入されます。

![insert_success.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/insert_success.png)

ここで表示されるレコードのタイトルは、先ほど作成したモデルクラス```BlogPost```の```__str__```関数の戻り値となっています。モデルクラスの```__str__```関数は、管理サイトに表示されるレコードを判別するための文字列を定義する役割があることがわかります。また、管理ページではレコードの選択・挿入の他、更新・削除も行えます。

## Webアプリからデータベースを操作する

管理サイトで動作確認が完了したら、実際にWebアプリからデータベースの操作（選択・挿入・更新・削除）が行えるようにモデルを実装します。まずは選択から確認していきます。

### シンプルにすべての要素を表示する

はじめに、トップページのビュー```IndexView```の継承元を、テンプレートを表示するだけの```TemplateView```からデータベースのデータを一覧表示するビュー```ListView```に変更します。テーブルの内容を編集することなくすべて表示する場合は（実際にはそのようなパターンは少ないですが）クラス変数の```model```に表示したいモデルのクラス名を指定します。このようにすることで、指定したモデルのすべてのレコードを取得して、指定したテンプレートでレンダリングします。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    model = BlogPost
```

テンプレートは動作確認用にシンプルなものを用意します。```index.html```を以下のように編集します。テンプレート側にはレコードのリストが```object_list```という変数で渡されるので、```for```で要素を1つずつ取得します。レコードの各要素は```.[カラム名]```でカラムの値を取得することができます。

```html
<!DOCTYPE html>
<html>
<head></head>
<body>
    {% for record in object_list %}
    <h3>{{record.title}}</h3>
    <p>{{record.content}}</p>
    {% endfor %}
</body>
</html>
```

### 並び替えてから表示する

SQLの```order by```構文で並べ替えた順番に表示したい場合は、```ordering```というクラス変数に並べ替えに使用するカラム名を指定します。複数のカラム名で並べ替えをする場合は、リストを追加していくだけでOKです。また、1つのカラム名で並べ替えをする場合は、文字列のリスト```['-posted_at']```ではなく文字列```'-posted_at'```だけでも動作します。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    model = BlogPost
    ordering = ['-posted_at']
```

また、```order_by```メソッドを使用することでも並べ替えが可能です。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    queryset = BlogPost.objects.order_by('-posted_at')
```

結果を格納する```queryset```は```ListView```のクラス変数で、テンプレートに渡されるレコードの一覧の実態になります。これまでの例のように```queryset```がオーバーライドされていないときは、```ListView```クラスは内部の```get_queryset```メソッドを実行し、```queryset = [クラス変数modelに格納されているモデルクラス].objects.all()```が実行され、全てのレコードが自動的に取得されます。したがって、シンプルな例は以下のように書き換えることも可能です。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    queryset = BlogPost.objects.all()
```

逆順で表示したい場合は、テンプレート側で```reversed```キーワードを追記することで対応できます。

```html
<!DOCTYPE html>
<html>
<head></head>
<body>
    {% for record in object_list reversed %}
    <h3>{{record.title}}</h3>
    <p>{{record.content}}</p>
    {% endfor %}
</body>
</html>
```

### 絞り込んで表示する

SQLの```where```構文で絞り込んだレコードのみ表示したい場合は、```filter```メソッドが利用できます。```order_by```と連結して使うことも可能です。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    queryset = BlogPost.objects.filter(category='Book').order_by('-posted_at')
```

### より複雑な操作をしたい場合

```get_queryset```メソッドをオーバーライドすることで、自由度の高い実装が可能になります。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    model = BlogPost

    def get_queryset(self, **kwargs):
        queryset = super().get_queryset(**kwargs)
        # 複雑な処理をここに書く
        queryset = queryset.filter(category='Book')
        queryset = queryset.order_by('-posted_at')
        return queryset
```

### テンプレートに渡すコンテキストを加工する

```get_context_data```メソッドをオーバーライドすることで、テンプレートに渡すコンテキストを加工することもできます。テンプレートに渡すコンテキストはdict型のオブジェクトになっており、データベースから取得したデータはコンテキストオブジェクトから```'object_list'```というキーで取得することができます。このコンテキストに対してキーの追加を行ったり、内容の変更を行う事が可能です。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    model = BlogPost

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['hello'] = 'Hello World!'
        return context
```

```html
<!DOCTYPE html>
<html>
<head></head>
<body>
    <h2>{{hello}}</h2>
    {% for record in object_list %}
    <h3>{{record.title}}</h3>
    <p>{{record.content}}</p>
    {% endfor %}
</body>
</html>
```

### テンプレートに渡すデータの別名を定義する

テンプレートでは```object_list```という変数でテーブルから取得したデータにアクセスしましたが、クラス変数```context_object_name```に名前を指定することで、任意の名前に変更することが可能です。

```py
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    model = BlogPost
    context_object_name = 'another_name'
```

```html
<!DOCTYPE html>
<html>
<head></head>
<body>
    {% for record in another_name %}
    <h3>{{record.title}}</h3>
    <p>{{record.content}}</p>
    {% endfor %}
</body>
</html>
```

[目次へ戻る](https://github.com/JuvenileTalk9/Django)
