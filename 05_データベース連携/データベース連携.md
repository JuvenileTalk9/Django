# データベース連携

4章までで、DjangoのMTVモデルのうち、T（Template）とV（View）の実装方法を確認しました。5章では、データベースを操作するM（Model）の実装方法を確認します。

DjangoにはデフォルトでSQLite3が搭載されており、初期設定でSQLite3にデータを書き込みます。ここではSQLite3を操作するモデルの実装方法を確認したあと、データベースシステムをPostgreSQLに変更する方法を確認します。

## 設定の確認

データベースに関する設定項目は、```settings.py```の```DATABASES```で管理されています。

```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

デフォルトで```ENGINE```にSQLite3が指定されており、プロジェクトディレクトリ直下の```db.sqlite3```ファイルが実態であることが```NAME```に設定されています。

## モデルを作成する

次に、モデルを実装します。モデルは```blog/models.py```に実装します。Djangoのモデルは、```django.db.models.Model```クラスを継承したサブクラスとして定義します。代表的なここではブログの投稿情報を管理する```BlogPost```クラスを作成します。管理する情報は以下とします。

|フィールド名|説明|型|オプション|
|:--|:--|:--|:--|
|id|記事ナンバー|整数（自動連番）|主キー|
|title|タイトル|文字列|256文字以下|
|content|本文|長い文字列|-|
|posted_at|投稿日時|日時|-|
|category|カテゴリ|文字列|読書・ゲーム・音楽から1つ選択|

Djangoは型ごとにフィールドクラスを定義しています。代表的なフィールドを示します。

|フィールドクラス名|概要|
|:--|:--|
|IntegerField|-2147483648～+2147483647の値の整数フィールド|
|AutoField|自動的に連番が振られるIntegerField|
|BigAutoField|より大きい整数値を格納できるAutoField|
|FloatField|浮動小数点のフィールド|
|BooleanField|真偽値のフィールド|
|CharField|文字列のフィールド。最大文字列長```max_length```を指定する必要がある|
|TextField|大きな文字列を格納するフィールド。```max_length```を指定する必要がない|
|DateField|日付のフィールド|
|TimeField|時刻のフィールド|
|DateTimeField|日時のフィールド|

これらを使って実装した```BlogPost```クラスは以下になります。

```py
class BlogPost(models.Model):

    CATEGORY = (('Book', '読書'), ('Game', 'ゲーム'), ('Music', '音楽'))

    id = models.AutoField(
        primary_key=True
    )

    title = models.CharField(
        varbose_name='タイトル',
        max_length=256
    )

    content = models.TextField(
        varbose_name='本文'
    )

    postged_at = models.DateTimeField(
        varbose_name='投稿日時',
        auto_now_add=True
    )

    category = models.CharField(
        varbose_name='カテゴリ',
        max_length=50,
        choices=CATEGORY
    )

    def __str__(self):
        return self.title
```

末尾に実装した```__str__```関数については後述します。

## マイグレーション

Djangoには、データベースのテーブルを作成する仕組みとして「マイグレーション」が実装されています。具体的には、先ほど作成したモデル定義を用いてテーブルを作成するPythonコードを自動で生成します。開発者は、生成されたコードを実行するだけでデータベースにテーブルを作成することができます。マイグレーションは、```manage.py```を用いて以下のように実行します。

```sh
$ python mangae.py makemigrations [アプリ名]
```

今回はアプリ名は```blog```になります。

``sh
$ python manage.py makemigrations blog
Migrations for 'blog':
  blog/migrations/0001_initial.py
    - Create model BlogPost
```

生成された```blog/migrations/0001_initial.py```は以下にようになっています。

```py
# Generated by Django 3.2 on 2021-07-08 15:34

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='BlogPost',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('title', models.CharField(max_length=256, verbose_name='タイトル')),
                ('content', models.TextField(verbose_name='本文')),
                ('postged_at', models.DateTimeField(auto_now_add=True, verbose_name='投稿日時')),
                ('category', models.CharField(choices=[('Book', '読書'), ('Game', 'ゲーム'), ('Music', '音楽')], max_length=50, verbose_name='カテゴリ')),
            ],
        ),
    ]
```

次に、生成されたマイグレーションファイルを実行し、テーブルの作成を行います。マイグレーションファイルの実行は、```migrate```オプションを使用します。

```sh
$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying blog.0001_initial... OK
  Applying sessions.0001_initial... OK
```

これでデータベースが作成され、Webアプリから操作できるようになりました。

## 管理ページからデータベースを操作する

```startapp```コマンドでblogを作成したときに、```admin.py```というモジュールも同時に生成されました。Djangoには登録したモデルに対してデータの追加・削除・編集が実験できる管理サイトが実装されており、```admin.py```はモデルの登録を行うモジュールになっています。```blog/admin.py```を以下のように編集します。

```py
from django.contrib import admin
from .models import BlogPost

admin.site.register(BlogPost)
```

Djangoの管理サイトはテーブルの情報が閲覧できてしまう重要なサイトのため、事前に登録された管理者ユーザのみログインできるような仕組みとなっています。管理者ユーザは```createsuperuser```コマンドで登録します。以下のようにユーザ名、メールアドレス、パスワードを登録します（外部に公開されるものではないので適当でOKです）。

```sh
$ python manage.py createsuperuser
ユーザー名 (leave blank to use 'centos'): centos
メールアドレス: admin@example.com
Password: 
Password (again): 
Superuser created successfully.
```

アカウントを作ったら開発用サーバを起動し、[http://127.0.0.1:8000/admin](http://127.0.0.1:8000/admin)に接続し、登録したユーザ名とパスワードでログインします。

![kanri_top.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/kanri_top.png)

Blog Postsの欄にある「追加ボタン」を押すと、テーブルに挿入するレコードの内容を入力できます。

![insert.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/insert.png)

「保存」ボタンでテーブルにレコードが挿入されます。

![insert_success.png](https://github.com/JuvenileTalk9/Django/blob/main/05_データベース連携/insert_success.png)

ここで表示されるレコードのタイトルは、先ほど作成したモデルクラス```BlogPost```の```__str__```関数の戻り値となっています。モデルクラスの```__str__```関数は、管理サイトに表示されるレコードを判別するための文字列を定義する役割があることがわかります。また、管理ページではレコードの選択・挿入の他、更新・削除も行えます。

## Webアプリからデータベースを操作する

管理サイトで動作確認が完了したら、実際にWebアプリからデータベースの操作（選択・挿入・更新・削除）が行えるようにモデルを実装します。まずは選択から確認していきます。

はじめに、トップページのビュー（```IndexView```）の継承元を、テンプレートを表示するだけの```TemplateView```からデータベースのデータを一覧表示するビュー```ListView```に変更します。

```py
from django.shortcuts import render
from django.views.generic import ListView
from .models import BlogPost

class IndexView(ListView):
    
    template_name = 'index.html'
    context_object_name = 'orderby_records'
    queryset = BlogPost.objects.order_by('-posted_at')
```


```context_object_name```は

ほげほげ

[目次へ戻る](https://github.com/JuvenileTalk9/Django)
