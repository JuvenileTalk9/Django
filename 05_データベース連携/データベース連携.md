# データベース連携

4章までで、DjangoのMTVモデルのうち、T（Template）とV（View）の実装方法を確認しました。5章では、データベースを操作するM（Model）の実装方法を確認します。

DjangoにはデフォルトでSQLite3が搭載されており、初期設定でSQLite3にデータを書き込みます。ここではSQLite3を操作するモデルの実装方法を確認したあと、データベースシステムをPostgreSQLに変更する方法を確認します。

## 設定の確認

データベースに関する設定項目は、```settings.py```の```DATABASES```で管理されています。

```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

デフォルトで```ENGINE```にSQLite3が指定されており、プロジェクトディレクトリ直下の```db.sqlite3```ファイルが実態であることが```NAME```に設定されています。

## モデルを作成する

次に、モデルを実装します。モデルは```blog/models.py```に実装します。Djangoのモデルは、```django.db.models.Model```クラスを継承したサブクラスとして定義します。代表的なここではブログの投稿情報を管理する```BlogPost```クラスを作成します。管理する情報は以下とします。

|フィールド名|説明|型|オプション|
|:--|:--|:--|:--|
|id|記事ナンバー|整数（自動連番）|主キー|
|title|タイトル|文字列|256文字以下|
|content|本文|長い文字列|-|
|posted_at|投稿日時|日時|-|
|category|カテゴリ|文字列|読書・ゲーム・音楽から1つ選択|

Djangoは型ごとにフィールドクラスを定義しています。代表的なフィールドを示します。

|フィールドクラス名|概要|
|:--|:--|
|IntegerField|-2147483648～+2147483647の値の整数フィールド|
|AutoField|自動的に連番が振られるIntegerField|
|BigAutoField|より大きい整数値を格納できるAutoField|
|FloatField|浮動小数点のフィールド|
|BooleanField|真偽値のフィールド|
|CharField|文字列のフィールド。最大文字列長```max_length```を指定する必要がある|
|TextField|大きな文字列を格納するフィールド。```max_length```を指定する必要がない|
|DateField|日付のフィールド|
|TimeField|時刻のフィールド|
|DateTimeField|日時のフィールド|

これらを使って実装した```BlogPost```クラスは以下になります。

```py
class BlogPost(models.Model):

    CATEGORY = ('Book', 'Game', 'Music')

    id = models.AutoField(
        primary_key=True
    )

    title = models.CharField(
        varbose_name='タイトル',
        max_length=256
    )

    content = models.TextField(
        varbose_name='本文'
    )

    postged_at = models.DateTimeField(
        varbose_name='投稿日時',
        auto_now_add=True
    )

    category = models.CharField(
        varbose_name='カテゴリ',
        max_length=50,
        choices=CATEGORY
    )
```




[目次へ戻る](https://github.com/JuvenileTalk9/Django)
